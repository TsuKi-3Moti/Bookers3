◆継承　スーパークラスを元に、機能を拡張したサブクラスを作るための機能
  親 スーパークラス
  子 サブクラス
  
  継承を用いて新しくサブクラスを定義
  ★「class サブクラス名 extends スーパークラス名」
  
  extends エクステンズ 拡張する
  
  ◇インスタンスメソッドの呼び出しやインスタンスフィールドへのアクセス方法はそのまま変わらない

    ※子から親という一方的なものが継承であるため、親が子のメソッドなどを使うことはできず、
      その場合エラーとなる
  
  メソッド呼び出しの優先順位
  ①子に該当するメソッドがあるか探す
  ②子になければ親に該当するメソッドがあるか探す
  

◆スーパークラスのメソッドをサブクラスでカスタマイズして使いたい
  優先順位的にサブクラスの方が上なので、
  オーバーライド
    カスタマイズしたものを同名のメソッド名でサブクラスに記述することで上書きのようにできる
  
  ※注意！ カプセル化によってゲッターを使用せねばならないことも多いので注意
  
    親のクラス名に付けるのではなく、thisを使用する
    this.getName()
  
  スーパークラスのメソッドの内容を呼び出して、オーバーライドする際の重複を減らす！
  サブクラスのインスタンスメソッドから、スーパークラスのインスタンスメソッドを呼び出すことが可能
  ★「super.メソッド名()」



◆サブクラスのコンストラクタ

  ※サブクラスのコンストラクタの先頭では
    super()を使ってスーパークラスのコンストラクタを呼びださなければならない！
    
    親 コンストラクタを定義し、フィールドに値をセットする
    子 コンストラクタを定義し、コンストラクタ内の先頭で 例 super(name, color);のようにして
       スーパークラスのコンストラクタを呼び出し、追加の処理をその後に記述する



◆抽象メソッド　abstract　アブストラクト　抽象的な
  具体的な処理が決まっていない未完成なメソッド
  
  スーパークラスに定義してしまいたいがサブクラスごとに処理が違うとき、
  未完成状態でスーパークラスに定義しておくメソッド
  
  つまり、サブクラスでその抽象メソッド内の処理をオーバーライドする前提で作られる！
    オーバーライドされなければエラーが発生させられるため、
    サブクラスがそのメソッドをオーバーライドし、処理内容を定義することを強制できる
    
  ★サブクラスにあるメソッドを必ず持たせたいという場合に使う！
  
  ・定義
  「public abstract void メソッド名(データ型 仮引数名);」{}は使わない
  親の方でabstractを付けることで抽象メソッドとなる
  
  ※抽象メソッドには中身の処理は書かない！
  
    子クラスでオーバーライドする際にはabstractは書かない！



◆抽象クラス 抽象メソッドを一つでも持つクラス

  クラス名の前にabstractをつける必要がある
  
  abstract class クラス名 {
  }
  
  ★抽象クラスはインスタンスを作成できなくなる！
    未完成なメソッドを持つクラスもまた未完成なクラスという扱いになる



◆クラス型のフィールド

  インスタンスフィールドにクラス型の変数を定義することで、
  フィールドにインスタンスを持つことが可能
  
  ゲッターセッターを定義することも可能
  ※戻り値の型と仮引数の型がクラス型に変わる
  
  ・呼び出し
    例 car.getOwner() // Carクラスのインスタンス(の格納された変数).メソッド
    
       これによって帰ってくる戻り値もPersonクラスのインスタンスであるため、
       
       car.getOwner().printData(); というように
       そのまま続けてPersonクラスのインスタンスメソッドprintDataを呼び出すことも可能
       
       関係性は変わらず、インスタンス.メソッド名の関係のままだから



◆多態性
  
  buyというPersonクラスのインスタンスがVehicleクラスのサブクラスである
  CarクラスやBicycleクラスのインスタンスを購入するメソッドであるとき、
  
  まずCarクラスのインスタンスの時と
  
  public void buy(Car car) {
    car.setOwner(this);
    // このcarの所有者を変更するメソッドにおける、
       誰？の値をthis(このbuyメソッドを呼び出しているPersonクラスのインスタンス)とする
  }
  
  同じようにBicycleクラスのインスタンスの時...というように、
  
  重複した記述が増え、また、今後もVehicleクラスのサブクラスが増えるたびに
  引数の型が違う同名のメソッドを定義していかなければならなくなる！
  
  ★引数としてスーパークラスであるVehicle型のインスタンスを受け取るようにすると、
    CarもBicycleもVehicle型を継承しているため、
    サブクラスのインスタンスを、スーパークラスのクラス型変数に代入することが可能になる
    このような特徴を「多態性（たたいせい）」
    
    ※親が例え抽象クラスでインスタンスを作れない状況にあっても、これは成立する
  
  